/***
 * This script will recover lost playlists from an older music library xml backup
 * 
 * It works by mapping the track IDs in the older library to the track file location, then
 * mapping the file location to the track ID in the current library. It then writes out XML
 * suitable for playlist import into the target output file.
 * 
 * Usage:
 * 
 *    node remap.js <old library file> <current library file> <playlist selection prefix> <output file>
 * 
 * Watch out that the "current" library export file is truly current, since it seems the track IDs can change.
 * 
 * It's good to have an import XML shell to drop the <dict> elements containing the revised playlist 
 * data into, and then you can run Library / Import playlist and pull in the recovered playlist(s). Note
 * that the library XML file is obtained by doing a Library/Export, and one of the first elements has the export
 * date under Date key.
 * 
 * Here's example:
   
    node remap.js "/Users/markmckenzie/Downloads/music app bkupLibrary.xml" "/Users/markmckenzie/Downloads/mc-current-library.xml" ~/import33.xml "1965-01-0"

 * 
 */

const getItunesPlaylists = require('../index').getItunesPlaylists;
const getItunesTracks = require('../index').getItunesTracks;
const fs = require('fs')

async function get_old_playlists(fn, match) {

    console.log('Example of how the getItunesPlaylists function works!');
    console.log('Begin get_old_playlists(' + fn + ',' + match + ')');

    const playlists = [];

    let validXML = fn; // "/Users/markmckenzie/Downloads/music app bkupLibrary.xml" //replace this with your xml path

    return new Promise(function (resolve, reject) {

        let stream = getItunesPlaylists(validXML)
        stream.on('data', function (res) {
            let playlist = JSON.parse(res);

            if (playlist['Name'].startsWith(match)) {
                //console.log(playlist);
                playlists.push(playlist);
            }

        })
        stream.on('error', function (err) {
            console.error(err);
            return reject();
        })
        stream.on('end', function (res) {
            return resolve(playlists);
        })

    })

}

async function get_old_id_to_track(fn) {

    console.log('Begin get_old_id_to_track(' + fn + ')');

    const gg = { "count": 0, "id_to_track": {} };

    let validXML = fn; // "/Users/markmckenzie/Downloads/music app bkupLibrary.xml" //replace this with your xml path

    return new Promise(function (resolve, reject) {

        let stream = getItunesTracks(validXML);
        stream.on('data', function (res) {
            let track = JSON.parse(res);
            gg.count++;
            gg.id_to_track[track["Track ID"]] = track;
        })
        stream.on('error', function (err) {
            console.error(err);
            return reject();
        })
        stream.on('end', function (res) {
            return resolve(gg);
        })

    })

}

async function get_new_loc_to_track(fn) {

    console.log('Begin get_new_loc_to_track(' + fn + ')');

    const gg = { "count": 0, "loc_to_track": {} };

    let validXML = fn; // "/Users/markmckenzie/Downloads/music app bkupLibrary.xml" //replace this with your xml path

    return new Promise(function (resolve, reject) {

        let stream = getItunesTracks(validXML);
        stream.on('data', function (res) {
            let track = JSON.parse(res);
            gg.count++;
            gg.loc_to_track[track.Location] = track;
        })
        stream.on('error', function (err) {
            console.error(err);
            return reject();
        })
        stream.on('end', function (res) {
            return resolve(gg);
        })

    })

}

async function zip(oldfn, newfn, playlist_match, output_fn) {
    console.log("zip/" + oldfn + "/" + newfn);
    const dat = {};
    await get_old_playlists(oldfn, playlist_match)
        .then(res => {

            console.log('finished!!!');
            dat.playlists = res;
        })

    await get_old_id_to_track(oldfn)
        .then(res => {
            dat.id_to_track = res.id_to_track;
            console.log('finished!!!');
        })

    await get_new_loc_to_track(newfn)
        .then(res => {
            dat.loc_to_track = res.loc_to_track;
            console.log('finished!!!');
        })

    if (dat.playlists.length > 0) {
        var buffer = "";
        // Here we build the xml file - this will only be the partial with the <dict> playlist entries.
        for (var i = 0; i < dat.playlists.length; i++) {
            //console.log(dat.playlists[i]);
            buffer += "\t\t<dict>\n";
            buffer += "\t\t\t<key>Name</key><string>-----" + escapeXml(dat.playlists[i].Name) + "</string>\n";
            buffer += "\t\t\t<key>Playlist Items</key>\n";
            buffer += "\t\t\t<array>\n";
            for (var j = 0; j < dat.playlists[i].tracks.length; j++) {
                //console.log(i, j, dat.playlists[i].tracks[j]);
                let t = dat.playlists[i].tracks[j];
                let l = dat.id_to_track[t];
                let nt = dat.loc_to_track[l.Location];
                if( !t ) {
                    console.log("no match for track in " + dat.playlists[i].Name);
                    console.log(t);
                } else {
                    buffer += "\t\t\t\t<dict>\n";
                    buffer += "\t\t\t\t\t<key>Track ID</key><integer>" + nt["Track ID"] + "</integer>\n";
                    buffer += "\t\t\t\t</dict>\n";    
                }
            }
            buffer += "\t\t\t</array>\n";
            buffer += "\t\t</dict>\n";
        }
        //console.log(buffer);
        // Write data in 'Hello.txt' .
        fs.writeFile(output_fn, buffer, (err) => {

            // In case of a error throw err.
            if (err) throw err;
        })


    }
    //console.log(dat.playlists);
}

function escapeXml(unsafe) {
    return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case '\'': return '&apos;';
            case '"': return '&quot;';
        }
    });
}



const args = process.argv.slice(2);
if (args.length != 4) {
    console.log("Need four parameters: old-xml current-xml playlist-match output-file");
} else {
    const oldfn = args[0]; //"/Users/markmckenzie/Downloads/music app bkupLibrary.xml";
    const newfn = args[1]; //"/Users/markmckenzie/Downloads/current-library.xml";
    const output_file = args[2];
    const playlist_match = args[3];
    console.log(args); // Output: ['arg1', 'arg2']
    zip(oldfn, newfn, playlist_match, output_file);
}
